#!/usr/bin/guile
!#

(import (sph tree) (sph)
  (sph list) (sph time string)
  (sph time) (sph alist)
  (sph cli) (sph upcoming)
  (sph time) (sph upcoming server) (sph io) (sph io read-write) (sph string) (sph lang indent-syntax))

; possible enhancements
;   allow event ids as start/end, which uses the references events start or end respectively
;   allow and/or/not combinations for event dependencies
;   remove duplicate event-id timepoints in output for more meaningful output

(define-as upcoming-cli-description-source list-qq
  "filter events in time with event definitions from a configuration file."
  "first start a server with \"upcoming --server\". if the server is running, use \"upcoming\" and other options to query events."
  (unquote
    (string-append "event definitions are loaded from the configuration file "
      (string-quote upcoming-config-path))))

(define-as upcoming-cli-about-source list-qq
  ("description" (unquote-splicing upcoming-cli-description-source))
  ("why use a server?"
    "the startup is quite processing intensive, particularly when calculating repeating events, event dependencies and filtering them."
    "since a main feature of sph-upcoming is to give frequent continuous updates about nearing events, ideally in real-time,"
    "pre-initialising the application on the server-side and then just querying it saves a lot of overhead")
  ("configuration file syntax" (unquote upcoming-doc-config-syntax))
  ("example configuration file" (unquote upcoming-doc-config-example)))

(define upcoming-cli-about (prefix-tree-text upcoming-cli-about-source))
(define upcoming-cli-description (prefix-tree-text upcoming-cli-description-source))
(define (client-get-one query) (upcoming-client (l (server) (write query server) (read server))))

(define (client-get-continuously query result proc)
  (upcoming-client
    (l (server) (write query server)
      (let loop ((response (read server)) (result result))
        (apply
          (l (continue? result)
            (if (or (eof-object? response) (not continue?)) result (loop (read server) result)))
          (proc response result))))))

(define (upcoming-cli)
  (let
    (options
      ( (cli-create #:description upcoming-cli-description
          #:about upcoming-cli-about
          #:options
          (list-q
            (next #:names #\n
              #:value-optional? #t #:type integer #:description "select up to n upcoming events")
            (previous #:names #\p
              #:value-optional? #t #:type integer #:description "select up to n previous events")
            ;(countdown #:names #\d #:description "count down to next events")
            (list #:names #\l #:description "list events")
            (diff #:description "display a new list relative to current time each interval seconds")
            ;(countup #:names #\u #:description "count up from the start of current events")
            (config #:names #\c
              #:value-required? #t #:description "use a different configuration file" #:type string)
            (interval #:value-required? #t
              #:type integer
              #:description "interval in seconds for functions that give continuous output")
            ((event-ids ...))
            (server #:names #\s #:description "start a server that can answer event queries")))))
    (alist-bind options (server next previous countdown countup config interval event-ids diff)
      (if server (upcoming-server)
        (let
          ( (o-list (alist-ref-q options list))
            (previous (if previous (* -1 (if (integer? previous) previous 1)) 0))
            (next (if next (if (integer? next) next 1) 1)))
          (cond
            (o-list
              (let*
                ( (time (ns->s (utc-current)))
                  (data
                    (client-get-one
                      (list (q upcoming-events-diff) time
                        previous next (or config upcoming-config-path)))))
                (if (or (eof-object? data) (null? data)) (display-line "")
                  (each
                    (l (a)
                      (let
                        ( (now-date-prefix (string-append (utc->ymd (s->ns time)) "_"))
                          (diff (first a)) (a (tail a)))
                        (display
                          (string-append (number->string diff) " "
                            (string-drop-prefix-if-exists now-date-prefix
                              (utc->ymd-ks (s->ns (event-start a))))
                            " "
                            (string-drop-prefix-if-exists now-date-prefix
                              (utc->ymd-ks (s->ns (event-end a))))
                            " " (symbol->string (event-id a)) "\n"))))
                    data))))
            (diff
              (client-get-continuously
                (list (q upcoming) (or interval 3) previous next (or config upcoming-config-path))
                (list)
                (l (data result)
                  (if (eof-object? data) (list #f result)
                    (if (null? data) (begin (display-line "") (list #t result))
                      (list #t
                        (begin
                          (each
                            (l (a)
                              (let
                                ( (now-date-prefix (string-append (utc->ymd (utc-current)) "_"))
                                  (diff (first a)) (a (tail a)))
                                (display
                                  (string-append (number->string diff) " "
                                    (string-drop-prefix-if-exists now-date-prefix
                                      (utc->ymd-ks (s->ns (event-start a))))
                                    " "
                                    (string-drop-prefix-if-exists now-date-prefix
                                      (utc->ymd-ks (s->ns (event-end a))))
                                    " " (symbol->string (event-id a)) "\n"))))
                            data)
                          (newline) result)))))))
            (else #f)))))))

(upcoming-cli)
